const Index = () => {
  return (
    <>
      <p>test</p>
    </>
  );
};

export default Index;
/*

[최소 신장 트리]
Q. 최소한의 비용으로 모든 정점을 연결하려면?
A. 필요한 간선 외에는 전부 제거.

1. 신장트리(Spanning Tree)
: 그래프 내에 모든 정점을 포함하는 최소 연결 부분 그래프.

2. 최소 신장 트리 (MST) 조건.
    - 최소한의 간선으로 모든 정점이 연결되어야 한다.
    - 모든 신장 트리 중 가중치의 값이 최소여야 한다.
    - Cycle이 발생해서는 안 됨.

3. 최소 신장 트리를 위한 알고리즘
    - 크루스칼 (Kruskal) // 이번 시간 다룰 내용.
    - 프림 (Prim)

[크루스칼 알고리즘이란?]
1. 그리디 개념 이용
2. 먼저 모든 그래프를 부분 집합으로 분리.
3. 가장 가중치가 낮은 간선 선택, 부분 집합을 연결.
4. Cycle이 발생하지 않도록 주의
    - 공통 최상위 부모를 찾는 것으로 막기 가능.
    - Cycle을 판단하기 위한 알고리즘.
    - Union-Find 알고리즘을 이용할 수 있다.

[Union-Find 알고리즘]
1. 서로소 집합을 구하기 위한 알고리즘.
    - 공통 원소가 없는 두 집합을 표현하기 위한 자료구조
2. 서로 다른 두 집합을 병합하는 연산 Union
    +
    집합의 원소가 어떤 집합에 속해 있는지 판단하는 연산 Find
3. 보통 트리 구조로 구성.
4. 편의상 재귀로 구현하는 경우 많음.

[Union]
1. 초기에는 자기 자신을 부모 정점으로 설정.
(자기 자신 = 자신이 속한 집합)

2. 최상위 원소에 따라 ...

(해당 구조만으론 각 원소가 어떤 집합에 속한지 알 수 없음.)

[Find]
1. 가장 간단한 방법
: parent가 자기 자신일 때 까지 올라가기.
(편향 트리일 경우 시간복잡도 O(n) 소모.)
=> 최적화 필요 => 경로 압축!

(최종 공통 부모를 알 수 있는 것을 이용.)
예) 재귀 구현 시 다시 돌아올 때 부모 값 변경.
=> 자연스럽게 경로가 최적화된다.

[Kruskal 풀이] // 많이 어려움. 복습 필요.

[정리]
1. Greedy : 가장 가중치가 낮은 간선부터 선택
2. Union-Find : 갹 원소가 같은 집합인지 확인하기 위한 알고리즘
3. Cycle : 두 정점이 같은 집합에 속한다면.





*/